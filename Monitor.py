#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# author: Xian Wu
# mail: wuxian94@pku.edu.cn
#

"""
BaseMonitor, base class of all the other monitor class.
One should never instantialize a monitor with type BaseMonitor but should derive a class from BaseMonitor.
When deriving a class, you are expected to implement all the abstract methods and follow the conventions:
    1. in the __init__ function, you should pass a unique 'name' to the super class, other parts of the subscriber
    will use name to identify every monitor.
    2. in the extract_content function, you are expected to implement the extracting method. You should return a
    serializable object which contains all the information you want.
    3. in the diff function, you are expected to implement the comparing method defined on your extracted content.
    You should return any object you like, such as a list of new items. We use None to denote that there is no
    difference between new and old content. What you return will be stored in the variable diff_content.
    4. in the gen_msg function, you are expected to generate all the message you want to pass to the announcer and
    return a dict-like object. Some keys are auto-generated by the master and you should not overwrite them, which
    are 'prev_content', 'new_content' and 'diff_content'. We strongly recommend that your msg contains following
    fields in order that announcers can access them correctly:
        msg: a brief description about this msg, such as "new item detected"
        status: a status code denoting your monitor status, we use 0 to denote that everything is ok
In general, you should take it into consideration that your monitor may be used with any announcer, so it is important
to follow the convention to ensure that everything is ok.
"""

import json
import os
from abc import abstractmethod, ABCMeta
from multiprocessing import Process
from multiprocessing import Queue
from time import sleep

from utils import StreamLogger


class BaseMonitor(object):
    __metaclass__ = ABCMeta
    ROOT_MSG_QUEUE = Queue()

    def __init__(self, name, interval=5*60, msg_queue=ROOT_MSG_QUEUE):
        """
        :param name: a unique identifier
        :param interval: for every interval seconds we extract the content
        :param msg_queue: pass message to master, you are not allowed to change it
        """
        self.__name = name
        self.interval = interval
        self.msg_queue = msg_queue
        self.save_filename = 'content_{}.json'.format(name)

        self.logger = StreamLogger.getLogger('(Monitor){}'.format(name))
        self.proc = Process(target=self.monitor_proc)

        self.prev_content = None
        self.now_content = None
        self.diff_content = None

    @property
    def name(self):
        return self.__name

    def monitor_proc(self):
        """
        main process of a monitor, when activated, the process will be run until deactivated.
        """
        if os.path.isfile(self.save_filename):
            self.prev_content = json.load(open(self.save_filename))
        while True:
            self.now_content = self.extract_content()
            if self.prev_content is None:
                self.prev_content = self.now_content
                json.dump(self.prev_content, open(self.save_filename, 'w'))
            self.diff_content = self.diff(self.prev_content, self.now_content)
            if self.diff_content:
                _keys = ['prev_content', 'now_content', 'diff_content']
                _msg = dict((k, self.__dict__[k]) for k in _keys)
                _msg.update(self.gen_msg())
                self.msg_queue.put((self.name, _msg))
                self.prev_content = self.now_content
            json.dump(self.prev_content, open(self.save_filename, 'w'))
            sleep(self.interval)

    def start(self):
        self.proc.start()
        self.logger.info('%s(%s) has been started.', self.name, self.proc.pid)

    def terminate(self):
        self.proc.terminate()
        self.logger.info('%s(%s) has been terminated.', self.name, self.proc.pid)

    @abstractmethod
    def extract_content(self):
        pass

    @abstractmethod
    def diff(self, prev_content, now_content):
        pass

    @abstractmethod
    def gen_msg(self):
        pass
